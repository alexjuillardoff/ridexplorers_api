<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Blog admin</title>
  <link rel="stylesheet" href="../style.css" />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/jsoneditor@latest/dist/jsoneditor.min.css"
  />
</head>
<body>
  <div class="navbar">
    <span class="api-name">RIDEXPLORERS API</span>
    <div class="navbar-right">
      <span class="auth-status" id="auth-status"></span>
      <form id="login-form">
        <input id="username" placeholder="Username" />
        <input type="password" id="password" placeholder="Password" />
        <button type="submit">Login</button>
      </form>
      <button id="logout-button" style="display:none;">Logout</button>
    </div>
  </div>
  <nav class="nav-links">
    <a href="/">Accueil</a>
    <a href="/docs" target="_blank">Swagger Docs</a>
    <a href="/files.html">Gestionnaire de fichiers</a>
    <a href="/blog/">Blog</a>
  </nav>
  <div class="container">
    <h1>Blog configuration</h1>
    <section>
      <h2>Flows</h2>
      <input id="search-input" placeholder="Search" />
      <table id="flows-table">
        <thead>
          <tr>
            <th data-sort="name" class="sortable">Name</th>
            <th data-sort="slug" class="sortable">Slug</th>
            <th data-sort="entriesCount" class="sortable">Entries</th>
            <th data-sort="updatedAt" class="sortable">Updated</th>
            <th>JSON</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div id="pagination"></div>
    </section>
    <section>
      <h2>Create flow</h2>
      <form id="flow-form" class="blog-form">
        <input name="name" placeholder="flow name" required />
        <input name="keys" placeholder="keys (comma separated)" />
        <button type="submit">Create</button>
      </form>
    </section>
    <section>
      <h2>Entries</h2>
      <form id="entry-form" class="blog-form">
        <input name="flow" placeholder="flow" required />
        <button type="button" id="load-entries">Load</button>
        <select id="entry-select">
          <option value="">New entry</option>
        </select>
        <div id="payload-editor"></div>
        <button type="submit">Save</button>
      </form>
    </section>
    <section>
      <h2>Upload JSON</h2>
      <form id="upload-form" class="blog-form" enctype="multipart/form-data">
        <input name="flow" placeholder="flow" required />
        <input type="file" name="file" accept="application/json" required />
        <button type="submit">Upload</button>
      </form>
    </section>
  </div>
  <div id="cookie-banner" class="cookie-banner">
    Ce site utilise des cookies techniques uniquement. <button id="accept-cookies">OK</button>
  </div>
  <script src="../login.js"></script>
  <script src="../cookies.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsoneditor@latest/dist/jsoneditor.min.js"></script>
  <script>
const flowForm = document.getElementById('flow-form');
flowForm.addEventListener('submit', async (e) => {
  e.preventDefault();
  const name = flowForm.name.value;
  const keys = flowForm.keys.value.split(',').map(k => k.trim()).filter(Boolean);
  await fetch('/api/blog/flows', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name, keys })
  });
  showToast('flow created');
  flowForm.reset();
});

const entryForm = document.getElementById('entry-form');
const loadEntriesBtn = document.getElementById('load-entries');
const entrySelect = document.getElementById('entry-select');
const payloadEditor = new JSONEditor(document.getElementById('payload-editor'), {
  mode: 'code',
  modes: ['code', 'tree']
});
let loadedEntries = [];
payloadEditor.set({});

async function loadEntries() {
  const flow = entryForm.flow.value;
  if (!flow) {
    alert('Missing flow');
    return;
  }
  try {
    const res = await fetch('/api/blog/' + flow + '?limit=100');
    if (!res.ok) throw new Error('Request failed');
    const data = await res.json();
    loadedEntries = data.items || [];
    entrySelect.innerHTML = '<option value="">New entry</option>';
    loadedEntries.forEach((entry) => {
      const opt = document.createElement('option');
      opt.value = entry.id;
      opt.textContent = entry.id;
      entrySelect.appendChild(opt);
    });
  } catch (err) {
    alert('Failed to load entries');
  }
}

loadEntriesBtn.addEventListener('click', loadEntries);

entrySelect.addEventListener('change', () => {
  const id = Number(entrySelect.value);
  if (!id) {
    payloadEditor.set({});
    return;
  }
  const entry = loadedEntries.find((e) => e.id === id);
  if (entry) payloadEditor.set(entry.payload);
});

entryForm.addEventListener('submit', async (e) => {
  e.preventDefault();
  const flow = entryForm.flow.value;
  let payload;
  try {
    payload = payloadEditor.get();
  } catch (err) {
    alert('Invalid JSON');
    return;
  }
  const entryId = entrySelect.value;
  const url = '/api/blog/' + flow + (entryId ? '/' + entryId : '');
  const method = entryId ? 'PATCH' : 'POST';
  const res = await fetch(url, {
    method,
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  if (!res.ok) {
    alert('Request failed');
    return;
  }
  showToast(entryId ? 'entry updated' : 'entry added');
  if (!entryId) payloadEditor.set({});
  entrySelect.value = '';
  await loadEntries();
});

const uploadForm = document.getElementById('upload-form');
uploadForm.addEventListener('submit', async (e) => {
  e.preventDefault();
  const flow = uploadForm.flow.value;
  const fd = new FormData(uploadForm);
  await fetch('/api/blog/' + flow + '/upload', { method: 'POST', body: fd });
  showToast('uploaded');
  uploadForm.reset();
});

let q = '';
let page = 1;
const limit = 10;
let sortField = '';
let sortDir = 'asc';

function showToast(message) {
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = message;
  document.body.appendChild(toast);
  requestAnimationFrame(() => toast.classList.add('show'));
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}

const searchInput = document.getElementById('search-input');
searchInput.addEventListener('input', (e) => {
  q = e.target.value;
  page = 1;
  loadFlows();
});

document.querySelectorAll('#flows-table th.sortable').forEach((th) => {
  th.addEventListener('click', () => {
    const field = th.getAttribute('data-sort');
    if (sortField === field) {
      sortDir = sortDir === 'asc' ? 'desc' : 'asc';
    } else {
      sortField = field;
      sortDir = 'asc';
    }
    page = 1;
    loadFlows();
  });
});

async function loadFlows() {
  const tbody = document.querySelector('#flows-table tbody');
  const params = new URLSearchParams({ q, page: String(page), limit: String(limit) });
  if (sortField) params.append('sort', `${sortField}:${sortDir}`);
  try {
    const res = await fetch('/api/blog/flows?' + params.toString());
    const data = await res.json();
    tbody.innerHTML = '';
    let items = data.items || [];
    if (sortField) {
      items.sort((a, b) => {
        const v1 = a[sortField];
        const v2 = b[sortField];
        if (v1 < v2) return sortDir === 'asc' ? -1 : 1;
        if (v1 > v2) return sortDir === 'asc' ? 1 : -1;
        return 0;
      });
    }
    items.forEach((flow) => {
      const url = `/api/blog/${flow.slug}`;
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${flow.name}</td>
        <td>${flow.slug}</td>
        <td>${flow.entriesCount}</td>
        <td>${flow.updatedAt}</td>
        <td><a href="${url}" target="_blank">JSON</a> <button class="copy-btn">Copy</button></td>
        <td>
          <button class="rename-btn">Rename</button>
          <button class="duplicate-btn">Duplicate</button>
          <button class="delete-btn">Delete</button>
        </td>`;

      const copyBtn = tr.querySelector('.copy-btn');
      copyBtn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(url);
          showToast('URL copied');
        } catch (err) {
          alert('Failed to copy');
        }
      });

      const renameBtn = tr.querySelector('.rename-btn');
      renameBtn.addEventListener('click', async () => {
        const newName = prompt('New name', flow.name);
        if (!newName) return;
        const newSlug = prompt('New slug', flow.slug);
        if (!newSlug) return;
        try {
          const res = await fetch(`/api/blog/flows/${flow.slug}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: newName, newSlug }),
          });
          if (!res.ok) throw new Error('Request failed');
          await loadFlows();
        } catch (e) {
          alert('Failed to rename flow');
        }
      });

      const duplicateBtn = tr.querySelector('.duplicate-btn');
      duplicateBtn.addEventListener('click', async () => {
        const newName = prompt('New name', flow.name + ' copy');
        if (!newName) return;
        const newSlug = prompt('New slug', flow.slug + '-copy');
        if (!newSlug) return;
        try {
          const res = await fetch(`/api/blog/flows/${flow.slug}/duplicate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ newName, newSlug }),
          });
          if (!res.ok) throw new Error('Request failed');
          await loadFlows();
        } catch (e) {
          alert('Failed to duplicate flow');
        }
      });

      const deleteBtn = tr.querySelector('.delete-btn');
      deleteBtn.addEventListener('click', async () => {
        const slug = flow.slug;
        if (!slug) {
          alert('Missing slug');
          return;
        }
        if (!confirm(`Delete flow "${flow.name}"?`)) return;
        try {
          const res = await fetch(`/api/blog/flows/${slug}`, { method: 'DELETE' });
          if (!res.ok) throw new Error('Request failed');
          await loadFlows();
        } catch (e) {
          alert('Failed to delete flow');
        }
      });

      tbody.appendChild(tr);
    });

    const pagination = document.getElementById('pagination');
    if (data.total > data.limit) {
      const totalPages = Math.ceil(data.total / data.limit);
      pagination.innerHTML = '';
      if (page > 1) {
        const prev = document.createElement('button');
        prev.textContent = 'Prev';
        prev.addEventListener('click', () => {
          page--;
          loadFlows();
        });
        pagination.appendChild(prev);
      }
      const info = document.createElement('span');
      info.textContent = `Page ${page} of ${totalPages}`;
      pagination.appendChild(info);
      if (page < totalPages) {
        const next = document.createElement('button');
        next.textContent = 'Next';
        next.addEventListener('click', () => {
          page++;
          loadFlows();
        });
        pagination.appendChild(next);
      }
    } else {
      pagination.innerHTML = '';
    }
  } catch (err) {
    tbody.innerHTML = '<tr><td colspan="6">Failed to load flows</td></tr>';
  }
}

window.addEventListener('load', loadFlows);
  </script>
</body>
</html>

